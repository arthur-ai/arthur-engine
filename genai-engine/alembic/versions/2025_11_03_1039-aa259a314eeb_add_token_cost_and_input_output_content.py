"""add_token_cost_and_input_output_content

Revision ID: aa259a314eeb
Revises: 2264832c91c0
Create Date: 2025-11-03 10:39:04.544418

"""

import json

import sqlalchemy as sa
from sqlalchemy import text
from tokencost import calculate_cost_by_tokens

from alembic import op

# revision identifiers, used by Alembic.
revision = "aa259a314eeb"
down_revision = "2264832c91c0"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column("spans", sa.Column("prompt_token_count", sa.Integer(), nullable=True))
    op.add_column(
        "spans",
        sa.Column("completion_token_count", sa.Integer(), nullable=True),
    )
    op.add_column("spans", sa.Column("total_token_count", sa.Integer(), nullable=True))
    op.add_column("spans", sa.Column("prompt_token_cost", sa.Float(), nullable=True))
    op.add_column(
        "spans",
        sa.Column("completion_token_cost", sa.Float(), nullable=True),
    )
    op.add_column("spans", sa.Column("total_token_cost", sa.Float(), nullable=True))
    op.create_index(
        "idx_spans_total_token_cost",
        "spans",
        ["total_token_cost"],
        unique=False,
    )
    op.create_index(
        "idx_spans_total_token_count",
        "spans",
        ["total_token_count"],
        unique=False,
    )
    op.add_column(
        "trace_metadata",
        sa.Column("prompt_token_count", sa.Integer(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("completion_token_count", sa.Integer(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("total_token_count", sa.Integer(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("prompt_token_cost", sa.Float(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("completion_token_cost", sa.Float(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("total_token_cost", sa.Float(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("input_content", sa.String(), nullable=True),
    )
    op.add_column(
        "trace_metadata",
        sa.Column("output_content", sa.String(), nullable=True),
    )
    op.create_index(
        "idx_traces_total_token_cost",
        "trace_metadata",
        ["total_token_cost"],
        unique=False,
    )
    op.create_index(
        "idx_traces_total_token_count",
        "trace_metadata",
        ["total_token_count"],
        unique=False,
    )
    # ### end Alembic commands ###

    _backfill_spans_token_data()
    _backfill_trace_metadata_token_data()
    _backfill_trace_metadata_input_output_content()


def _backfill_spans_token_data():
    """Backfill spans table with token counts and costs extracted from raw_data JSON."""
    connection = op.get_bind()

    # Extract token counts and costs from JSONB
    op.execute(
        text(
            """
        UPDATE spans
        SET
            prompt_token_count = (raw_data->'attributes'->'llm'->'token_count'->>'prompt')::integer,
            completion_token_count = (raw_data->'attributes'->'llm'->'token_count'->>'completion')::integer,
            total_token_count = COALESCE(
                (raw_data->'attributes'->'llm'->'token_count'->>'total')::integer,
                (raw_data->'attributes'->'llm'->'token_count'->>'prompt')::integer +
                (raw_data->'attributes'->'llm'->'token_count'->>'completion')::integer
            ),
            prompt_token_cost = (raw_data->'attributes'->'llm'->'cost'->>'prompt')::float,
            completion_token_cost = (raw_data->'attributes'->'llm'->'cost'->>'completion')::float,
            total_token_cost = COALESCE(
                (raw_data->'attributes'->'llm'->'cost'->>'total')::float,
                (raw_data->'attributes'->'llm'->'cost'->>'prompt')::float +
                (raw_data->'attributes'->'llm'->'cost'->>'completion')::float
            )
        WHERE
            raw_data->'attributes'->'llm' IS NOT NULL
            AND raw_data->'attributes'->'llm'->'token_count' IS NOT NULL
    """,
        ),
    )

    # For spans with token counts but no costs, compute using tokencost
    _compute_missing_costs(connection)


def _compute_missing_costs(connection):
    """Compute costs for spans that have token counts but missing costs."""
    # Find spans with token counts but missing at least one cost field
    # Note: We need model_name to compute costs
    result = connection.execute(
        text(
            """
        SELECT id,
               prompt_token_count,
               completion_token_count,
               total_token_count,
               prompt_token_cost,
               completion_token_cost,
               total_token_cost,
               raw_data->'attributes'->'llm'->>'model_name' as model_name
        FROM spans
        WHERE (prompt_token_count IS NOT NULL OR completion_token_count IS NOT NULL OR total_token_count IS NOT NULL)
          AND (prompt_token_cost IS NULL OR completion_token_cost IS NULL OR total_token_cost IS NULL)
          AND raw_data->'attributes'->'llm'->>'model_name' IS NOT NULL
    """,
        ),
    )

    rows = result.fetchall()

    for row in rows:
        (
            span_id,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            existing_prompt_cost,
            existing_completion_cost,
            existing_total_cost,
            model_name,
        ) = row

        try:
            # Start with existing costs
            prompt_cost = existing_prompt_cost
            completion_cost = existing_completion_cost
            total_cost = existing_total_cost

            # Compute prompt cost if missing
            if prompt_tokens and prompt_cost is None:
                prompt_cost = float(
                    calculate_cost_by_tokens(
                        num_tokens=prompt_tokens,
                        model=model_name,
                        token_type="input",
                    ),
                )

            # Compute completion cost if missing
            if completion_tokens and completion_cost is None:
                completion_cost = float(
                    calculate_cost_by_tokens(
                        num_tokens=completion_tokens,
                        model=model_name,
                        token_type="output",
                    ),
                )

            # Compute total cost if missing
            if total_cost is None:
                # Prefer computing from total_token_count if available
                if total_tokens:
                    total_cost = float(
                        calculate_cost_by_tokens(
                            num_tokens=total_tokens,
                            model=model_name,
                            token_type="output",
                        ),
                    )
                # Fallback to summing prompt_cost + completion_cost
                elif prompt_cost is not None and completion_cost is not None:
                    total_cost = prompt_cost + completion_cost

            # Update the span if any costs changed
            if (
                prompt_cost != existing_prompt_cost
                or completion_cost != existing_completion_cost
                or total_cost != existing_total_cost
            ):
                connection.execute(
                    text(
                        """
                        UPDATE spans
                        SET prompt_token_cost = :prompt_cost,
                            completion_token_cost = :completion_cost,
                            total_token_cost = :total_cost
                        WHERE id = :span_id
                    """,
                    ),
                    {
                        "prompt_cost": prompt_cost,
                        "completion_cost": completion_cost,
                        "total_cost": total_cost,
                        "span_id": span_id,
                    },
                )

        except Exception:
            continue


def _backfill_trace_metadata_token_data():
    """Backfill trace_metadata by aggregating token counts and costs from spans."""
    # Similar to how span_count was backfilled in the trace_metadata creation migration
    # Use NULL-safe aggregation - SUM returns NULL if all values are NULL
    op.execute(
        text(
            """
        UPDATE trace_metadata tm
        SET
            prompt_token_count = agg.prompt_token_count,
            completion_token_count = agg.completion_token_count,
            total_token_count = agg.total_token_count,
            prompt_token_cost = agg.prompt_token_cost,
            completion_token_cost = agg.completion_token_cost,
            total_token_cost = agg.total_token_cost
        FROM (
            SELECT
                trace_id,
                SUM(prompt_token_count) as prompt_token_count,
                SUM(completion_token_count) as completion_token_count,
                SUM(total_token_count) as total_token_count,
                SUM(prompt_token_cost) as prompt_token_cost,
                SUM(completion_token_cost) as completion_token_cost,
                SUM(total_token_cost) as total_token_cost
            FROM spans
            GROUP BY trace_id
        ) agg
        WHERE tm.trace_id = agg.trace_id
    """,
        ),
    )


def _backfill_trace_metadata_input_output_content():
    """Backfill trace_metadata input/output content from root spans."""
    connection = op.get_bind()

    # For each trace, find the earliest root span (no parent_span_id)
    # and extract its input and output values
    result = connection.execute(
        text(
            """
        SELECT DISTINCT ON (trace_id)
            trace_id,
            raw_data->'attributes'->'input'->'value' as input_value,
            raw_data->'attributes'->'output'->'value' as output_value
        FROM spans
        WHERE parent_span_id IS NULL
        ORDER BY trace_id, start_time ASC
    """,
        ),
    )

    rows = result.fetchall()

    for row in rows:
        trace_id, input_value, output_value = row

        # Convert values to strings (JSON dumps if dict/list, otherwise as-is)
        input_content = _value_to_string(input_value)
        output_content = _value_to_string(output_value)

        # Update trace_metadata with the extracted content
        connection.execute(
            text(
                """
                UPDATE trace_metadata
                SET input_content = :input_content,
                    output_content = :output_content
                WHERE trace_id = :trace_id
            """,
            ),
            {
                "input_content": input_content,
                "output_content": output_content,
                "trace_id": trace_id,
            },
        )


def _value_to_string(value):
    """Convert a value to string format."""
    if value is None:
        return None
    if isinstance(value, (dict, list)):
        return json.dumps(value)
    return str(value)


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index("idx_traces_total_token_count", table_name="trace_metadata")
    op.drop_index("idx_traces_total_token_cost", table_name="trace_metadata")
    op.drop_column("trace_metadata", "output_content")
    op.drop_column("trace_metadata", "input_content")
    op.drop_column("trace_metadata", "total_token_cost")
    op.drop_column("trace_metadata", "completion_token_cost")
    op.drop_column("trace_metadata", "prompt_token_cost")
    op.drop_column("trace_metadata", "total_token_count")
    op.drop_column("trace_metadata", "completion_token_count")
    op.drop_column("trace_metadata", "prompt_token_count")
    op.drop_index("idx_spans_total_token_count", table_name="spans")
    op.drop_index("idx_spans_total_token_cost", table_name="spans")
    op.drop_column("spans", "total_token_cost")
    op.drop_column("spans", "completion_token_cost")
    op.drop_column("spans", "prompt_token_cost")
    op.drop_column("spans", "total_token_count")
    op.drop_column("spans", "completion_token_count")
    op.drop_column("spans", "prompt_token_count")
    # ### end Alembic commands ###
