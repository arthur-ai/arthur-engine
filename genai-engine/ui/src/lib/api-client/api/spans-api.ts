/* tslint:disable */
/* eslint-disable */
/**
 * Arthur GenAI Engine
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.1.79
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { PaginationSortMethod } from '../models';
// @ts-ignore
import type { QuerySpansResponse } from '../models';
// @ts-ignore
import type { QueryTracesWithMetricsResponse } from '../models';
// @ts-ignore
import type { SpanWithMetricsResponse } from '../models';
// @ts-ignore
import type { ToolClassEnum } from '../models';
/**
 * SpansApi - axios parameter creator
 * @export
 */
export const SpansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Compute metrics for a single span. Validates that the span is an LLM span.
         * @summary Compute Metrics for Span
         * @param {string} spanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeSpanMetricsV1SpanSpanIdMetricsGet: async (spanId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spanId' is not null or undefined
            assertParamExists('computeSpanMetricsV1SpanSpanIdMetricsGet', 'spanId', spanId)
            const localVarPath = `/v1/span/{span_id}/metrics`
                .replace(`{${"span_id"}}`, encodeURIComponent(String(spanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query spans filtered by span type. Task IDs are required. Returns spans with any existing metrics but does not compute new ones.
         * @summary Query Spans By Type
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansByTypeV1SpansQueryGet: async (taskIds: Array<string>, spanTypes?: Array<string>, startTime?: string, endTime?: string, sort?: PaginationSortMethod, pageSize?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskIds' is not null or undefined
            assertParamExists('querySpansByTypeV1SpansQueryGet', 'taskIds', taskIds)
            const localVarPath = `/v1/spans/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taskIds) {
                localVarQueryParameter['task_ids'] = taskIds;
            }

            if (spanTypes) {
                localVarQueryParameter['span_types'] = spanTypes;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query traces with comprehensive filtering. Returns traces containing spans that match the filters, not just the spans themselves.
         * @summary Query Traces
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {Array<string>} [traceIds] Trace IDs to filter on. Optional.
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [toolName] Return only results with this tool name.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {number} [queryRelevanceEq] Equal to this value.
         * @param {number} [queryRelevanceGt] Greater than this value.
         * @param {number} [queryRelevanceGte] Greater than or equal to this value.
         * @param {number} [queryRelevanceLt] Less than this value.
         * @param {number} [queryRelevanceLte] Less than or equal to this value.
         * @param {number} [responseRelevanceEq] Equal to this value.
         * @param {number} [responseRelevanceGt] Greater than this value.
         * @param {number} [responseRelevanceGte] Greater than or equal to this value.
         * @param {number} [responseRelevanceLt] Less than this value.
         * @param {number} [responseRelevanceLte] Less than or equal to this value.
         * @param {ToolClassEnum} [toolSelection] Tool selection evaluation result.
         * @param {ToolClassEnum} [toolUsage] Tool usage evaluation result.
         * @param {number} [traceDurationEq] Duration exactly equal to this value (seconds).
         * @param {number} [traceDurationGt] Duration greater than this value (seconds).
         * @param {number} [traceDurationGte] Duration greater than or equal to this value (seconds).
         * @param {number} [traceDurationLt] Duration less than this value (seconds).
         * @param {number} [traceDurationLte] Duration less than or equal to this value (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansV1TracesQueryGet: async (taskIds: Array<string>, sort?: PaginationSortMethod, pageSize?: number, page?: number, traceIds?: Array<string>, startTime?: string, endTime?: string, toolName?: string, spanTypes?: Array<string>, queryRelevanceEq?: number, queryRelevanceGt?: number, queryRelevanceGte?: number, queryRelevanceLt?: number, queryRelevanceLte?: number, responseRelevanceEq?: number, responseRelevanceGt?: number, responseRelevanceGte?: number, responseRelevanceLt?: number, responseRelevanceLte?: number, toolSelection?: ToolClassEnum, toolUsage?: ToolClassEnum, traceDurationEq?: number, traceDurationGt?: number, traceDurationGte?: number, traceDurationLt?: number, traceDurationLte?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskIds' is not null or undefined
            assertParamExists('querySpansV1TracesQueryGet', 'taskIds', taskIds)
            const localVarPath = `/v1/traces/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (taskIds) {
                localVarQueryParameter['task_ids'] = taskIds;
            }

            if (traceIds) {
                localVarQueryParameter['trace_ids'] = traceIds;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (toolName !== undefined) {
                localVarQueryParameter['tool_name'] = toolName;
            }

            if (spanTypes) {
                localVarQueryParameter['span_types'] = spanTypes;
            }

            if (queryRelevanceEq !== undefined) {
                localVarQueryParameter['query_relevance_eq'] = queryRelevanceEq;
            }

            if (queryRelevanceGt !== undefined) {
                localVarQueryParameter['query_relevance_gt'] = queryRelevanceGt;
            }

            if (queryRelevanceGte !== undefined) {
                localVarQueryParameter['query_relevance_gte'] = queryRelevanceGte;
            }

            if (queryRelevanceLt !== undefined) {
                localVarQueryParameter['query_relevance_lt'] = queryRelevanceLt;
            }

            if (queryRelevanceLte !== undefined) {
                localVarQueryParameter['query_relevance_lte'] = queryRelevanceLte;
            }

            if (responseRelevanceEq !== undefined) {
                localVarQueryParameter['response_relevance_eq'] = responseRelevanceEq;
            }

            if (responseRelevanceGt !== undefined) {
                localVarQueryParameter['response_relevance_gt'] = responseRelevanceGt;
            }

            if (responseRelevanceGte !== undefined) {
                localVarQueryParameter['response_relevance_gte'] = responseRelevanceGte;
            }

            if (responseRelevanceLt !== undefined) {
                localVarQueryParameter['response_relevance_lt'] = responseRelevanceLt;
            }

            if (responseRelevanceLte !== undefined) {
                localVarQueryParameter['response_relevance_lte'] = responseRelevanceLte;
            }

            if (toolSelection !== undefined) {
                localVarQueryParameter['tool_selection'] = toolSelection;
            }

            if (toolUsage !== undefined) {
                localVarQueryParameter['tool_usage'] = toolUsage;
            }

            if (traceDurationEq !== undefined) {
                localVarQueryParameter['trace_duration_eq'] = traceDurationEq;
            }

            if (traceDurationGt !== undefined) {
                localVarQueryParameter['trace_duration_gt'] = traceDurationGt;
            }

            if (traceDurationGte !== undefined) {
                localVarQueryParameter['trace_duration_gte'] = traceDurationGte;
            }

            if (traceDurationLt !== undefined) {
                localVarQueryParameter['trace_duration_lt'] = traceDurationLt;
            }

            if (traceDurationLte !== undefined) {
                localVarQueryParameter['trace_duration_lte'] = traceDurationLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query traces with comprehensive filtering and compute metrics. Returns traces containing spans that match the filters with computed metrics.
         * @summary Compute Missing Metrics and Query Traces
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {Array<string>} [traceIds] Trace IDs to filter on. Optional.
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [toolName] Return only results with this tool name.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {number} [queryRelevanceEq] Equal to this value.
         * @param {number} [queryRelevanceGt] Greater than this value.
         * @param {number} [queryRelevanceGte] Greater than or equal to this value.
         * @param {number} [queryRelevanceLt] Less than this value.
         * @param {number} [queryRelevanceLte] Less than or equal to this value.
         * @param {number} [responseRelevanceEq] Equal to this value.
         * @param {number} [responseRelevanceGt] Greater than this value.
         * @param {number} [responseRelevanceGte] Greater than or equal to this value.
         * @param {number} [responseRelevanceLt] Less than this value.
         * @param {number} [responseRelevanceLte] Less than or equal to this value.
         * @param {ToolClassEnum} [toolSelection] Tool selection evaluation result.
         * @param {ToolClassEnum} [toolUsage] Tool usage evaluation result.
         * @param {number} [traceDurationEq] Duration exactly equal to this value (seconds).
         * @param {number} [traceDurationGt] Duration greater than this value (seconds).
         * @param {number} [traceDurationGte] Duration greater than or equal to this value (seconds).
         * @param {number} [traceDurationLt] Duration less than this value (seconds).
         * @param {number} [traceDurationLte] Duration less than or equal to this value (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansWithMetricsV1TracesMetricsGet: async (taskIds: Array<string>, sort?: PaginationSortMethod, pageSize?: number, page?: number, traceIds?: Array<string>, startTime?: string, endTime?: string, toolName?: string, spanTypes?: Array<string>, queryRelevanceEq?: number, queryRelevanceGt?: number, queryRelevanceGte?: number, queryRelevanceLt?: number, queryRelevanceLte?: number, responseRelevanceEq?: number, responseRelevanceGt?: number, responseRelevanceGte?: number, responseRelevanceLt?: number, responseRelevanceLte?: number, toolSelection?: ToolClassEnum, toolUsage?: ToolClassEnum, traceDurationEq?: number, traceDurationGt?: number, traceDurationGte?: number, traceDurationLt?: number, traceDurationLte?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskIds' is not null or undefined
            assertParamExists('querySpansWithMetricsV1TracesMetricsGet', 'taskIds', taskIds)
            const localVarPath = `/v1/traces/metrics/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (taskIds) {
                localVarQueryParameter['task_ids'] = taskIds;
            }

            if (traceIds) {
                localVarQueryParameter['trace_ids'] = traceIds;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (toolName !== undefined) {
                localVarQueryParameter['tool_name'] = toolName;
            }

            if (spanTypes) {
                localVarQueryParameter['span_types'] = spanTypes;
            }

            if (queryRelevanceEq !== undefined) {
                localVarQueryParameter['query_relevance_eq'] = queryRelevanceEq;
            }

            if (queryRelevanceGt !== undefined) {
                localVarQueryParameter['query_relevance_gt'] = queryRelevanceGt;
            }

            if (queryRelevanceGte !== undefined) {
                localVarQueryParameter['query_relevance_gte'] = queryRelevanceGte;
            }

            if (queryRelevanceLt !== undefined) {
                localVarQueryParameter['query_relevance_lt'] = queryRelevanceLt;
            }

            if (queryRelevanceLte !== undefined) {
                localVarQueryParameter['query_relevance_lte'] = queryRelevanceLte;
            }

            if (responseRelevanceEq !== undefined) {
                localVarQueryParameter['response_relevance_eq'] = responseRelevanceEq;
            }

            if (responseRelevanceGt !== undefined) {
                localVarQueryParameter['response_relevance_gt'] = responseRelevanceGt;
            }

            if (responseRelevanceGte !== undefined) {
                localVarQueryParameter['response_relevance_gte'] = responseRelevanceGte;
            }

            if (responseRelevanceLt !== undefined) {
                localVarQueryParameter['response_relevance_lt'] = responseRelevanceLt;
            }

            if (responseRelevanceLte !== undefined) {
                localVarQueryParameter['response_relevance_lte'] = responseRelevanceLte;
            }

            if (toolSelection !== undefined) {
                localVarQueryParameter['tool_selection'] = toolSelection;
            }

            if (toolUsage !== undefined) {
                localVarQueryParameter['tool_usage'] = toolUsage;
            }

            if (traceDurationEq !== undefined) {
                localVarQueryParameter['trace_duration_eq'] = traceDurationEq;
            }

            if (traceDurationGt !== undefined) {
                localVarQueryParameter['trace_duration_gt'] = traceDurationGt;
            }

            if (traceDurationGte !== undefined) {
                localVarQueryParameter['trace_duration_gte'] = traceDurationGte;
            }

            if (traceDurationLt !== undefined) {
                localVarQueryParameter['trace_duration_lt'] = traceDurationLt;
            }

            if (traceDurationLte !== undefined) {
                localVarQueryParameter['trace_duration_lte'] = traceDurationLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpansApi - functional programming interface
 * @export
 */
export const SpansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpansApiAxiosParamCreator(configuration)
    return {
        /**
         * Compute metrics for a single span. Validates that the span is an LLM span.
         * @summary Compute Metrics for Span
         * @param {string} spanId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeSpanMetricsV1SpanSpanIdMetricsGet(spanId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpanWithMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeSpanMetricsV1SpanSpanIdMetricsGet(spanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpansApi.computeSpanMetricsV1SpanSpanIdMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query spans filtered by span type. Task IDs are required. Returns spans with any existing metrics but does not compute new ones.
         * @summary Query Spans By Type
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySpansByTypeV1SpansQueryGet(taskIds: Array<string>, spanTypes?: Array<string>, startTime?: string, endTime?: string, sort?: PaginationSortMethod, pageSize?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySpansResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySpansByTypeV1SpansQueryGet(taskIds, spanTypes, startTime, endTime, sort, pageSize, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpansApi.querySpansByTypeV1SpansQueryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query traces with comprehensive filtering. Returns traces containing spans that match the filters, not just the spans themselves.
         * @summary Query Traces
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {Array<string>} [traceIds] Trace IDs to filter on. Optional.
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [toolName] Return only results with this tool name.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {number} [queryRelevanceEq] Equal to this value.
         * @param {number} [queryRelevanceGt] Greater than this value.
         * @param {number} [queryRelevanceGte] Greater than or equal to this value.
         * @param {number} [queryRelevanceLt] Less than this value.
         * @param {number} [queryRelevanceLte] Less than or equal to this value.
         * @param {number} [responseRelevanceEq] Equal to this value.
         * @param {number} [responseRelevanceGt] Greater than this value.
         * @param {number} [responseRelevanceGte] Greater than or equal to this value.
         * @param {number} [responseRelevanceLt] Less than this value.
         * @param {number} [responseRelevanceLte] Less than or equal to this value.
         * @param {ToolClassEnum} [toolSelection] Tool selection evaluation result.
         * @param {ToolClassEnum} [toolUsage] Tool usage evaluation result.
         * @param {number} [traceDurationEq] Duration exactly equal to this value (seconds).
         * @param {number} [traceDurationGt] Duration greater than this value (seconds).
         * @param {number} [traceDurationGte] Duration greater than or equal to this value (seconds).
         * @param {number} [traceDurationLt] Duration less than this value (seconds).
         * @param {number} [traceDurationLte] Duration less than or equal to this value (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySpansV1TracesQueryGet(taskIds: Array<string>, sort?: PaginationSortMethod, pageSize?: number, page?: number, traceIds?: Array<string>, startTime?: string, endTime?: string, toolName?: string, spanTypes?: Array<string>, queryRelevanceEq?: number, queryRelevanceGt?: number, queryRelevanceGte?: number, queryRelevanceLt?: number, queryRelevanceLte?: number, responseRelevanceEq?: number, responseRelevanceGt?: number, responseRelevanceGte?: number, responseRelevanceLt?: number, responseRelevanceLte?: number, toolSelection?: ToolClassEnum, toolUsage?: ToolClassEnum, traceDurationEq?: number, traceDurationGt?: number, traceDurationGte?: number, traceDurationLt?: number, traceDurationLte?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTracesWithMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySpansV1TracesQueryGet(taskIds, sort, pageSize, page, traceIds, startTime, endTime, toolName, spanTypes, queryRelevanceEq, queryRelevanceGt, queryRelevanceGte, queryRelevanceLt, queryRelevanceLte, responseRelevanceEq, responseRelevanceGt, responseRelevanceGte, responseRelevanceLt, responseRelevanceLte, toolSelection, toolUsage, traceDurationEq, traceDurationGt, traceDurationGte, traceDurationLt, traceDurationLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpansApi.querySpansV1TracesQueryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query traces with comprehensive filtering and compute metrics. Returns traces containing spans that match the filters with computed metrics.
         * @summary Compute Missing Metrics and Query Traces
         * @param {Array<string>} taskIds Task IDs to filter on. At least one is required.
         * @param {PaginationSortMethod} [sort] Sort the results (asc/desc)
         * @param {number} [pageSize] Page size. Default is 10. Must be greater than 0 and less than 5000.
         * @param {number} [page] Page number
         * @param {Array<string>} [traceIds] Trace IDs to filter on. Optional.
         * @param {string} [startTime] Inclusive start date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [endTime] Exclusive end date in ISO8601 string format. Use local time (not UTC).
         * @param {string} [toolName] Return only results with this tool name.
         * @param {Array<string>} [spanTypes] Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
         * @param {number} [queryRelevanceEq] Equal to this value.
         * @param {number} [queryRelevanceGt] Greater than this value.
         * @param {number} [queryRelevanceGte] Greater than or equal to this value.
         * @param {number} [queryRelevanceLt] Less than this value.
         * @param {number} [queryRelevanceLte] Less than or equal to this value.
         * @param {number} [responseRelevanceEq] Equal to this value.
         * @param {number} [responseRelevanceGt] Greater than this value.
         * @param {number} [responseRelevanceGte] Greater than or equal to this value.
         * @param {number} [responseRelevanceLt] Less than this value.
         * @param {number} [responseRelevanceLte] Less than or equal to this value.
         * @param {ToolClassEnum} [toolSelection] Tool selection evaluation result.
         * @param {ToolClassEnum} [toolUsage] Tool usage evaluation result.
         * @param {number} [traceDurationEq] Duration exactly equal to this value (seconds).
         * @param {number} [traceDurationGt] Duration greater than this value (seconds).
         * @param {number} [traceDurationGte] Duration greater than or equal to this value (seconds).
         * @param {number} [traceDurationLt] Duration less than this value (seconds).
         * @param {number} [traceDurationLte] Duration less than or equal to this value (seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySpansWithMetricsV1TracesMetricsGet(taskIds: Array<string>, sort?: PaginationSortMethod, pageSize?: number, page?: number, traceIds?: Array<string>, startTime?: string, endTime?: string, toolName?: string, spanTypes?: Array<string>, queryRelevanceEq?: number, queryRelevanceGt?: number, queryRelevanceGte?: number, queryRelevanceLt?: number, queryRelevanceLte?: number, responseRelevanceEq?: number, responseRelevanceGt?: number, responseRelevanceGte?: number, responseRelevanceLt?: number, responseRelevanceLte?: number, toolSelection?: ToolClassEnum, toolUsage?: ToolClassEnum, traceDurationEq?: number, traceDurationGt?: number, traceDurationGte?: number, traceDurationLt?: number, traceDurationLte?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTracesWithMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySpansWithMetricsV1TracesMetricsGet(taskIds, sort, pageSize, page, traceIds, startTime, endTime, toolName, spanTypes, queryRelevanceEq, queryRelevanceGt, queryRelevanceGte, queryRelevanceLt, queryRelevanceLte, responseRelevanceEq, responseRelevanceGt, responseRelevanceGte, responseRelevanceLt, responseRelevanceLte, toolSelection, toolUsage, traceDurationEq, traceDurationGt, traceDurationGte, traceDurationLt, traceDurationLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SpansApi.querySpansWithMetricsV1TracesMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SpansApi - factory interface
 * @export
 */
export const SpansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpansApiFp(configuration)
    return {
        /**
         * Compute metrics for a single span. Validates that the span is an LLM span.
         * @summary Compute Metrics for Span
         * @param {SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeSpanMetricsV1SpanSpanIdMetricsGet(requestParameters: SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SpanWithMetricsResponse> {
            return localVarFp.computeSpanMetricsV1SpanSpanIdMetricsGet(requestParameters.spanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query spans filtered by span type. Task IDs are required. Returns spans with any existing metrics but does not compute new ones.
         * @summary Query Spans By Type
         * @param {SpansApiQuerySpansByTypeV1SpansQueryGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansByTypeV1SpansQueryGet(requestParameters: SpansApiQuerySpansByTypeV1SpansQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuerySpansResponse> {
            return localVarFp.querySpansByTypeV1SpansQueryGet(requestParameters.taskIds, requestParameters.spanTypes, requestParameters.startTime, requestParameters.endTime, requestParameters.sort, requestParameters.pageSize, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * Query traces with comprehensive filtering. Returns traces containing spans that match the filters, not just the spans themselves.
         * @summary Query Traces
         * @param {SpansApiQuerySpansV1TracesQueryGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansV1TracesQueryGet(requestParameters: SpansApiQuerySpansV1TracesQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryTracesWithMetricsResponse> {
            return localVarFp.querySpansV1TracesQueryGet(requestParameters.taskIds, requestParameters.sort, requestParameters.pageSize, requestParameters.page, requestParameters.traceIds, requestParameters.startTime, requestParameters.endTime, requestParameters.toolName, requestParameters.spanTypes, requestParameters.queryRelevanceEq, requestParameters.queryRelevanceGt, requestParameters.queryRelevanceGte, requestParameters.queryRelevanceLt, requestParameters.queryRelevanceLte, requestParameters.responseRelevanceEq, requestParameters.responseRelevanceGt, requestParameters.responseRelevanceGte, requestParameters.responseRelevanceLt, requestParameters.responseRelevanceLte, requestParameters.toolSelection, requestParameters.toolUsage, requestParameters.traceDurationEq, requestParameters.traceDurationGt, requestParameters.traceDurationGte, requestParameters.traceDurationLt, requestParameters.traceDurationLte, options).then((request) => request(axios, basePath));
        },
        /**
         * Query traces with comprehensive filtering and compute metrics. Returns traces containing spans that match the filters with computed metrics.
         * @summary Compute Missing Metrics and Query Traces
         * @param {SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySpansWithMetricsV1TracesMetricsGet(requestParameters: SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryTracesWithMetricsResponse> {
            return localVarFp.querySpansWithMetricsV1TracesMetricsGet(requestParameters.taskIds, requestParameters.sort, requestParameters.pageSize, requestParameters.page, requestParameters.traceIds, requestParameters.startTime, requestParameters.endTime, requestParameters.toolName, requestParameters.spanTypes, requestParameters.queryRelevanceEq, requestParameters.queryRelevanceGt, requestParameters.queryRelevanceGte, requestParameters.queryRelevanceLt, requestParameters.queryRelevanceLte, requestParameters.responseRelevanceEq, requestParameters.responseRelevanceGt, requestParameters.responseRelevanceGte, requestParameters.responseRelevanceLt, requestParameters.responseRelevanceLte, requestParameters.toolSelection, requestParameters.toolUsage, requestParameters.traceDurationEq, requestParameters.traceDurationGt, requestParameters.traceDurationGte, requestParameters.traceDurationLt, requestParameters.traceDurationLte, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpansApi - interface
 * @export
 * @interface SpansApi
 */
export interface SpansApiInterface {
    /**
     * Compute metrics for a single span. Validates that the span is an LLM span.
     * @summary Compute Metrics for Span
     * @param {SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApiInterface
     */
    computeSpanMetricsV1SpanSpanIdMetricsGet(requestParameters: SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SpanWithMetricsResponse>;

    /**
     * Query spans filtered by span type. Task IDs are required. Returns spans with any existing metrics but does not compute new ones.
     * @summary Query Spans By Type
     * @param {SpansApiQuerySpansByTypeV1SpansQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApiInterface
     */
    querySpansByTypeV1SpansQueryGet(requestParameters: SpansApiQuerySpansByTypeV1SpansQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuerySpansResponse>;

    /**
     * Query traces with comprehensive filtering. Returns traces containing spans that match the filters, not just the spans themselves.
     * @summary Query Traces
     * @param {SpansApiQuerySpansV1TracesQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApiInterface
     */
    querySpansV1TracesQueryGet(requestParameters: SpansApiQuerySpansV1TracesQueryGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryTracesWithMetricsResponse>;

    /**
     * Query traces with comprehensive filtering and compute metrics. Returns traces containing spans that match the filters with computed metrics.
     * @summary Compute Missing Metrics and Query Traces
     * @param {SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApiInterface
     */
    querySpansWithMetricsV1TracesMetricsGet(requestParameters: SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryTracesWithMetricsResponse>;

}

/**
 * Request parameters for computeSpanMetricsV1SpanSpanIdMetricsGet operation in SpansApi.
 * @export
 * @interface SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest
 */
export interface SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGet
     */
    readonly spanId: string
}

/**
 * Request parameters for querySpansByTypeV1SpansQueryGet operation in SpansApi.
 * @export
 * @interface SpansApiQuerySpansByTypeV1SpansQueryGetRequest
 */
export interface SpansApiQuerySpansByTypeV1SpansQueryGetRequest {
    /**
     * Task IDs to filter on. At least one is required.
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly taskIds: Array<string>

    /**
     * Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly spanTypes?: Array<string>

    /**
     * Inclusive start date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly startTime?: string

    /**
     * Exclusive end date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly endTime?: string

    /**
     * Sort the results (asc/desc)
     * @type {PaginationSortMethod}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly sort?: PaginationSortMethod

    /**
     * Page size. Default is 10. Must be greater than 0 and less than 5000.
     * @type {number}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly pageSize?: number

    /**
     * Page number
     * @type {number}
     * @memberof SpansApiQuerySpansByTypeV1SpansQueryGet
     */
    readonly page?: number
}

/**
 * Request parameters for querySpansV1TracesQueryGet operation in SpansApi.
 * @export
 * @interface SpansApiQuerySpansV1TracesQueryGetRequest
 */
export interface SpansApiQuerySpansV1TracesQueryGetRequest {
    /**
     * Task IDs to filter on. At least one is required.
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly taskIds: Array<string>

    /**
     * Sort the results (asc/desc)
     * @type {PaginationSortMethod}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly sort?: PaginationSortMethod

    /**
     * Page size. Default is 10. Must be greater than 0 and less than 5000.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly pageSize?: number

    /**
     * Page number
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly page?: number

    /**
     * Trace IDs to filter on. Optional.
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceIds?: Array<string>

    /**
     * Inclusive start date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly startTime?: string

    /**
     * Exclusive end date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly endTime?: string

    /**
     * Return only results with this tool name.
     * @type {string}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly toolName?: string

    /**
     * Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly spanTypes?: Array<string>

    /**
     * Equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly queryRelevanceEq?: number

    /**
     * Greater than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly queryRelevanceGt?: number

    /**
     * Greater than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly queryRelevanceGte?: number

    /**
     * Less than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly queryRelevanceLt?: number

    /**
     * Less than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly queryRelevanceLte?: number

    /**
     * Equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly responseRelevanceEq?: number

    /**
     * Greater than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly responseRelevanceGt?: number

    /**
     * Greater than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly responseRelevanceGte?: number

    /**
     * Less than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly responseRelevanceLt?: number

    /**
     * Less than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly responseRelevanceLte?: number

    /**
     * Tool selection evaluation result.
     * @type {ToolClassEnum}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly toolSelection?: ToolClassEnum

    /**
     * Tool usage evaluation result.
     * @type {ToolClassEnum}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly toolUsage?: ToolClassEnum

    /**
     * Duration exactly equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceDurationEq?: number

    /**
     * Duration greater than this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceDurationGt?: number

    /**
     * Duration greater than or equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceDurationGte?: number

    /**
     * Duration less than this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceDurationLt?: number

    /**
     * Duration less than or equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansV1TracesQueryGet
     */
    readonly traceDurationLte?: number
}

/**
 * Request parameters for querySpansWithMetricsV1TracesMetricsGet operation in SpansApi.
 * @export
 * @interface SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest
 */
export interface SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest {
    /**
     * Task IDs to filter on. At least one is required.
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly taskIds: Array<string>

    /**
     * Sort the results (asc/desc)
     * @type {PaginationSortMethod}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly sort?: PaginationSortMethod

    /**
     * Page size. Default is 10. Must be greater than 0 and less than 5000.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly pageSize?: number

    /**
     * Page number
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly page?: number

    /**
     * Trace IDs to filter on. Optional.
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceIds?: Array<string>

    /**
     * Inclusive start date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly startTime?: string

    /**
     * Exclusive end date in ISO8601 string format. Use local time (not UTC).
     * @type {string}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly endTime?: string

    /**
     * Return only results with this tool name.
     * @type {string}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly toolName?: string

    /**
     * Span types to filter on. Optional. Valid values: AGENT, CHAIN, EMBEDDING, EVALUATOR, GUARDRAIL, LLM, RERANKER, RETRIEVER, TOOL, UNKNOWN
     * @type {Array<string>}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly spanTypes?: Array<string>

    /**
     * Equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly queryRelevanceEq?: number

    /**
     * Greater than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly queryRelevanceGt?: number

    /**
     * Greater than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly queryRelevanceGte?: number

    /**
     * Less than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly queryRelevanceLt?: number

    /**
     * Less than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly queryRelevanceLte?: number

    /**
     * Equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly responseRelevanceEq?: number

    /**
     * Greater than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly responseRelevanceGt?: number

    /**
     * Greater than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly responseRelevanceGte?: number

    /**
     * Less than this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly responseRelevanceLt?: number

    /**
     * Less than or equal to this value.
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly responseRelevanceLte?: number

    /**
     * Tool selection evaluation result.
     * @type {ToolClassEnum}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly toolSelection?: ToolClassEnum

    /**
     * Tool usage evaluation result.
     * @type {ToolClassEnum}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly toolUsage?: ToolClassEnum

    /**
     * Duration exactly equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceDurationEq?: number

    /**
     * Duration greater than this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceDurationGt?: number

    /**
     * Duration greater than or equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceDurationGte?: number

    /**
     * Duration less than this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceDurationLt?: number

    /**
     * Duration less than or equal to this value (seconds).
     * @type {number}
     * @memberof SpansApiQuerySpansWithMetricsV1TracesMetricsGet
     */
    readonly traceDurationLte?: number
}

/**
 * SpansApi - object-oriented interface
 * @export
 * @class SpansApi
 * @extends {BaseAPI}
 */
export class SpansApi extends BaseAPI implements SpansApiInterface {
    /**
     * Compute metrics for a single span. Validates that the span is an LLM span.
     * @summary Compute Metrics for Span
     * @param {SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApi
     */
    public computeSpanMetricsV1SpanSpanIdMetricsGet(requestParameters: SpansApiComputeSpanMetricsV1SpanSpanIdMetricsGetRequest, options?: RawAxiosRequestConfig) {
        return SpansApiFp(this.configuration).computeSpanMetricsV1SpanSpanIdMetricsGet(requestParameters.spanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query spans filtered by span type. Task IDs are required. Returns spans with any existing metrics but does not compute new ones.
     * @summary Query Spans By Type
     * @param {SpansApiQuerySpansByTypeV1SpansQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApi
     */
    public querySpansByTypeV1SpansQueryGet(requestParameters: SpansApiQuerySpansByTypeV1SpansQueryGetRequest, options?: RawAxiosRequestConfig) {
        return SpansApiFp(this.configuration).querySpansByTypeV1SpansQueryGet(requestParameters.taskIds, requestParameters.spanTypes, requestParameters.startTime, requestParameters.endTime, requestParameters.sort, requestParameters.pageSize, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query traces with comprehensive filtering. Returns traces containing spans that match the filters, not just the spans themselves.
     * @summary Query Traces
     * @param {SpansApiQuerySpansV1TracesQueryGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApi
     */
    public querySpansV1TracesQueryGet(requestParameters: SpansApiQuerySpansV1TracesQueryGetRequest, options?: RawAxiosRequestConfig) {
        return SpansApiFp(this.configuration).querySpansV1TracesQueryGet(requestParameters.taskIds, requestParameters.sort, requestParameters.pageSize, requestParameters.page, requestParameters.traceIds, requestParameters.startTime, requestParameters.endTime, requestParameters.toolName, requestParameters.spanTypes, requestParameters.queryRelevanceEq, requestParameters.queryRelevanceGt, requestParameters.queryRelevanceGte, requestParameters.queryRelevanceLt, requestParameters.queryRelevanceLte, requestParameters.responseRelevanceEq, requestParameters.responseRelevanceGt, requestParameters.responseRelevanceGte, requestParameters.responseRelevanceLt, requestParameters.responseRelevanceLte, requestParameters.toolSelection, requestParameters.toolUsage, requestParameters.traceDurationEq, requestParameters.traceDurationGt, requestParameters.traceDurationGte, requestParameters.traceDurationLt, requestParameters.traceDurationLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query traces with comprehensive filtering and compute metrics. Returns traces containing spans that match the filters with computed metrics.
     * @summary Compute Missing Metrics and Query Traces
     * @param {SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpansApi
     */
    public querySpansWithMetricsV1TracesMetricsGet(requestParameters: SpansApiQuerySpansWithMetricsV1TracesMetricsGetRequest, options?: RawAxiosRequestConfig) {
        return SpansApiFp(this.configuration).querySpansWithMetricsV1TracesMetricsGet(requestParameters.taskIds, requestParameters.sort, requestParameters.pageSize, requestParameters.page, requestParameters.traceIds, requestParameters.startTime, requestParameters.endTime, requestParameters.toolName, requestParameters.spanTypes, requestParameters.queryRelevanceEq, requestParameters.queryRelevanceGt, requestParameters.queryRelevanceGte, requestParameters.queryRelevanceLt, requestParameters.queryRelevanceLte, requestParameters.responseRelevanceEq, requestParameters.responseRelevanceGt, requestParameters.responseRelevanceGte, requestParameters.responseRelevanceLt, requestParameters.responseRelevanceLte, requestParameters.toolSelection, requestParameters.toolUsage, requestParameters.traceDurationEq, requestParameters.traceDurationGt, requestParameters.traceDurationGte, requestParameters.traceDurationLt, requestParameters.traceDurationLte, options).then((request) => request(this.axios, this.basePath));
    }
}

